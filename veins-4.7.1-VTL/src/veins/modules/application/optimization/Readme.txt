/***************************************************************************************************************************************
*                                                               README
****************************************************************************************************************************************/

//Describing the workflow of the optimizer

/*******************************
1)          DATASET
********************************/
/*

The dataset it's the container which contains all the possible solutions generated by all the possible configurations at the intersection.
These solutions can be printed to a file or to the console. In addition they can be printed in a easy to read formato or into an xml format.

The xml formato it's needed in order to initialized the dataset to be used instead of launching each time the algorithm. In this way it's possible to reduce
drastically the execution, in order to directly save the dataset into a variable.

The Dataset is designed so that the container it's a map with key an array of 4 double, representing the 4 directions form E to S in counterclockwise order. (E,N,W,S)
In particulare they are: -3.14, -1.57, 0.0, 1.57; the value for the key it's a vector<array<pait<int, int>, 4>>. The vector allows to collecto solutions: each array
represent a solution, each pair contains as first index the position of the vehicle in the queue and the second index represent it's signal.
When the algorithm test the possibilities assign the tested signal if it is possible, otherwise it assign 1 as signal. In this way it create all possible solutions.

If not altready existing it's possible o generte this dataset calling the fuction: 
TestAllPossibility(Chess &myChess,	std::map<std::array<double, 4>, std::vector<std::array<std::pair<int, int>, 4>>>& mapDataset, int signals = 7, std::string mode = "", std::string destination = "");

Refers to its definition for input explanation.


Loading dataset from xml:
Once the dataset is available, it's possible loading it with the function:

rxml::readfile("path")

It store into a variable std::map<std::array<double, 4>, std::vector<std::array<std::pair<int, int>, 4>>> Dataset; the dataset.
*/


/*******************************
2)   VEHICLE INITIALIZATION
********************************/
/*
Vehicles present int the research must be collected so in vectors. In particular for each direction I have to have two vector, one describing the position in queue of 
vehicles, the other describing theri signal. For example:
std::vector<int> EastVechicles = {1,2,3,4,5,6};
std::vector<int> EastSignals =   {2,2,3,4,3,4};   with 2=right, 3=left, 4=straight
...
*/


/**********************************************
3)    COLLECT ALL VEHICLES IN ONE VARIABLE
**********************************************/
/*
Once obtained all vectors for each direction, it's possible to create a variable which describe how those vehicles are placed into the map.
Using a std::map<double, std::vector<Car>> inputVeichels; variable.
It's possible to pass from a group of vector to one variable using the function:

inputVehicles = opt::CarInMap(Evehicles, Esignals, Nvehicles, Nsignals, Wvehicles, Wsignals, Svehicles, Ssignals);
*/

//  4) OPTIONAL, INSERT VEHICLES IN THE INTERSECTION
/*
opt::CarInMap2Chess(myChess, inputVehicles);
This function allows to insert into the intersection (myChess) the vehicles collected into the inputVehicles variable obtained in the previous step.

This step it's optional because I don't use the intersection to test results, because the possible solutions are available thanks to the dataset.
*/


/**************************************
5)   COLLECTING VEHICLES IN CIRCLES
**************************************/
/*
Definition of circle of vehicles:
    For semplicity it's been defined circle of vehicles a group of vehicles which are in different direction, but at the same queue position.
For example there is a circle of first vehicles, a circle of vehicles in the second position, ... .

For the algorithm it's needed that vehicles are grouped in this configuration, so a function which allow to move from the description of vehicles based on direction
to a description of vehicles based on circle it's been generated.

This function is:

std::map<int, std::vector<Car>> my_variable = opt::mapVehicleByCircle(inputVehicles);

where the key represent the queue position and the corresponing value represent the circle of vehicles.
*/


/*******************************************************************************
6)  RECURSIVE FUNCTION FOR SEARCH OF MAXIMIZE THE NUMBER OF PASSING VEHICLES
*******************************************************************************/
/*
This function allows to search in less the 1s which are the solutions of each circle of vehicles and based on those compute the other solution in ordeer to empty the intersection.
All those solutions are mapped based on their number, so that the more they are, the more it's the time needed to empty the intersection.

The function is:
void opt::Recursive(std::map<int, std::vector<Car>> VehicleMap, std::vector<std::vector<Car>> testedSolutions, std::map<int, std::vector<std::vector<std::vector<Car>>>>& FullSolutions, std::map<std::array<double, 4>, std::vector<std::array<std::pair<int, int>, 4>>> mapDataset)

Check the function definition for variable meaning.

For the following configuration, the execution time in 398ms.
heading = -3.14 position = 1 signal = 2
heading = -3.14 position = 2 signal = 4
heading = -3.14 position = 3 signal = 3
heading = -3.14 position = 4 signal = 4
heading = -1.57 position = 1 signal = 2
heading = -1.57 position = 2 signal = 4
heading = -1.57 position = 3 signal = 3
heading = -1.57 position = 4 signal = 2
heading = 0 position = 1 signal = 4
heading = 0 position = 2 signal = 4
heading = 0 position = 3 signal = 2
heading = 1.57 position = 1 signal = 4
heading = 1.57 position = 2 signal = 2 
*/

/************************************
7)  SETTING THE STRT AND STOP
************************************/
/*
For each solution founded the correct Start and Stop of vehicles is setted. The start and stop is rappresented using 2 variables in the Car class definition.
They are incremented by a function setSettedSignal(int signal), which takes care of the current situation of the vehicles, so if the vehicle is already stopped and 
another stop signal is passed to the function, the counter does not increment. The same happened for the start counter.

Each Car start with a Start=1, and Stop=0; if the vehicles is stopped by a circle solution, the StopCounter is incremented and Start=0, Stop=1; The stop counter can be
incremented only with Start=1 and Sop=0. In an analogue way the StartCounter is managed.
*/

/***********************************
8)  CHOOSING THE BEST SOLUTION 
************************************/
/*
Based on the number of start and stop produced by each solution in the solution map generated by the recursion, the one with the lower number of start and stop
it's selected as best solution. 
If exists solutions which have the same number of solution per circle to empty the intersection and the same number of start and stop, the first solution founded in the 
research it's taken
*/



/*
In this way given a certain configuration:
the number of vehicles it's been maximized, the number of circle's solution it's been minimized and the number of start and stop it's been minimized
*/
